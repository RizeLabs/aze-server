# use.miden::contracts::poker::poker
use.miden::account
use.miden::tx
use.std::crypto::dsa::rpo_falcon512
use.miden::contracts::wallets::basic->basic_wallet
use.miden::contracts::auth::basic

# index corresponding to the information saved
const.PLAYER_1_PUB_KEY_INDEX=65 # use this index to find other player pub key slot index which would always be second to the player account id
const.SMALL_BLIND_INDEX=56
const.BIG_BLIND_INDEX=57
const.BUY_IN_INDEX=58
const.NO_OF_PLAYERS_INDEX=59
const.CURRENT_TURN_INDEX=60 # index of the player whose turn it is currently
const.RAISER_INDEX=61
const.CURRENT_TURN_PLAYER_PUB_KEY_INDEX=63 # need to check it's storage initially small blind public key on slot 62
const.CURRENT_PLAYER_PUB_KEY_INDEX=62 # at 63 we stored pub key for current player (it will contain)
const.HIGHEST_BET_SLOT_INDEX=64 # highest bet amount which player will try to match with call
const.CURRENT_PHASE=65 # whole game is divided into 4 phases

const.NEXT_ACTIVE_PLAYER_KEY_INDEX=67 # next active player key index
# game events 
# TODO: fix some storage for the value corresponding to these events 
const.PLAYER_BETTED_AMOUNT=169 # check slot (169 - 100) 
const.NEXT_PLAYER_TURN=170 # check slot (170 - 100)
const.CARD_REVEALED=171 # check slot (171 - 100)
const.NEW_HIGHEST_BET=172 # check slot (172 - 100)
const.BALANCE_UPDATED=173 # check slot (173 - 100)
const.PLAYER_ACTION=174 # check slot (174 - 100)
const.GAME_ENDED=175 # check slot (175 - 100)

# enable authentication for players (although accounts are custodial for now)
export.poker_auth_tx_rpo_falcon512
    # Get commitments to created notes
    exec.tx::get_output_notes_hash
    # => [OUTPUT_NOTES_HASH, ...]

    # Get commitments to consumed notes
    exec.tx::get_input_notes_hash
    # => [INPUT_NOTES_HASH, OUTPUT_NOTES_HASH, ...]

    # Get current nonce of the account and pad
    exec.account::get_nonce push.0.0.0
    # => [0, 0, 0, nonce, INPUT_NOTES_HASH, OUTPUT_NOTES_HASH, ...]

    # Get current AccountID and pad
    exec.account::get_id push.0.0.0
    # => [0, 0, 0, account_id, 0, 0, 0, nonce, INPUT_NOTES_HASH, OUTPUT_NOTES_HASH, ...]

    # Compute the message to be signed
    # M = h(OUTPUT_NOTES_HASH, h(INPUT_NOTES_HASH, h(0, 0, 0, account_id, 0, 0, 0, nonce)))
    hmerge hmerge hmerge

    # Get public key from account storage at pos 0 and verify signature
    push.CURRENT_TURN_PLAYER_PUB_KEY_INDEX exec.account::get_item
    # => [PUB_KEY, M]

    # Verify the signature against the public key and the message. The procedure gets as
    # inputs the hash of the public key and the hash of the message via the operand
    # stack. The signature is provided via the advice stack. The signature is valid if and
    # only if the procedure returns.
    exec.rpo_falcon512::verify
    # => []

    # Update the nonce
    push.1 exec.account::incr_nonce
    # => []
end

export.play_call

    # although we will enforce this checks from frontend but it's go to have certain require here
    # TODO: checks the player isn't folded 
    # TODO: checks the player has enough amount for matching bet
    # TODO: checks the first player can't go for check  

    # loaded current player index 
    push.CURRENT_TURN_PLAYER_PUB_KEY_INDEX exec.account::get_item
    # => [0, 0, 0, pub key index of current player]
    
    # dropping three zeroes 
    drop drop drop

    # => [pub key index of current player]
    push.2 add exec.account::get_item
    # => [0, 0, 0, player last bet]
    drop drop drop
    # => [player last bet]
    # when user wants to just call and match the bet
    push.HIGHEST_BET_SLOT_INDEX exec.account::get_item 
    # => [0, 0, 0, highest bet, player last bet] since we are currently storing everything in word 
    drop drop drop
    # => [0, 0, 0, highest bet, current bet]
    drop drop drop
    sub 
    # => [highest bet - current bet] subtract this amount from player balance 
    # => [difference]
    push.CURRENT_TURN_PLAYER_PUB_KEY_INDEX
    push.3 add exec.account::get_item
    drop drop drop
    # => [balance, difference]
    sub
    # => [balance - difference]
    push.CURRENT_TURN_PLAYER_PUB_KEY_INDEX.3
    # => updated player balance 
    exec.account::set_item 

    # TODO: need to add procedure for updating player turns
end

# need to setup asm build first for this 
# export.poker::play_call
# export.poker::play_raise
# export.poker::play_fold
# export.poker::play_check

export.play_raise

    # raise amount = current player bet
    push.CURRENT_PLAYER_PUB_KEY_INDEX drop drop drop
    # [current turn pub key index]

    push.2 add
    # [current turn pub key index + 2, ]

    exec.account.get_item drop drop drop
    # [player_bet]

    # Tasks need to be performed:
    # - update highest bet slot 62 âœ…
    # - update raiser âœ…
    # - update the remaining balance of player âœ…
    # - update player bet = 0 ??
    # - update the pot value ?? 
    # - update phase/round n sum âœ…
    # - increase the slot to next player who is playing ðŸ‘€

    # update highest bet
    
    push.HIGHEST_BET_SLOT_INDEX drop drop drop 
    #[HIGHEST_BET_SLOT_INDEX, player_bet]

    exec.account.set_item
    #[]

    # update raiser

    push.CURRENT_PLAYER_PUB_KEY_INDEX drop drop drop
    #[CURRENT_PLAYER_PUB_KEY_INDEX]

    push.RAISER_INDEX
    #[RAISER_INDEX, CURRENT_PLAYER_PUB_KEY_INDEX]

    exec.account.set_item
    #[]


    # update the remaining balance of player 

    push.CURRENT_PLAYER_PUB_KEY_INDEX drop drop drop
    # [CURRENT_PLAYER_PUB_KEY_INDEX]

    push.3 add
    # [CURRENT_PLAYER_PUB_KEY_INDEX + 3]

    dup
    # [CURRENT_PLAYER_PUB_KEY_INDEX + 3, CURRENT_PLAYER_PUB_KEY_INDEX + 3]


    exec.account.get_item drop drop drop 
    # [player_remaining_balance, CURRENT_PLAYER_PUB_KEY_INDEX + 3]

    push.HIGHEST_BET_SLOT_INDEX drop drop drop
    # [HIGHEST_BET_SLOT_INDEX, player_remaining_balance, CURRENT_PLAYER_PUB_KEY_INDEX + 3]

    exec.account.get_item drop drop drop 
    # [player_bet, player_remaining_balance, CURRENT_PLAYER_PUB_KEY_INDEX + 3]
    
    sub
    # [player_balance_after_bet, CURRENT_PLAYER_PUB_KEY_INDEX + 3]

    dup push.0 
    # [0, player_balance_after_bet ,player_balance_after_bet, CURRENT_PLAYER_PUB_KEY_INDEX + 3]

    gte
    # [1/0 ,player_balance_after_bet, CURRENT_PLAYER_PUB_KEY_INDEX + 3]

    assert
    # [player_balance_after_bet, CURRENT_PLAYER_PUB_KEY_INDEX + 3]

    swap
    # [CURRENT_PLAYER_PUB_KEY_INDEX + 3, player_balance_after_bet]

    exec.account.set_item
    # []


    # - update phase/round n sum

    push.CURRENT_TURN_INDEX drop drop drop
    #[CURRENT_TURN_INDEX]

    push.4 add
    #[CURRENT_TURN_INDEX+4]

    push.CURRENT_PHASE drop drop drop
    #[CURRENT_PHASE, CURRENT_TURN_INDEX+4]

    add push.1 swap sub dup
    #[CURRENT_PHASE + CURRENT_TURN_INDEX + 4 -1, CURRENT_PHASE + CURRENT_TURN_INDEX + 4 -1 ]

    exec.account.get_item drop drop drop 
    #[phase_n_sum, CURRENT_PHASE + CURRENT_TURN_INDEX + 4 -1]

    push.HIGHEST_BET_SLOT_INDEX drop drop drop
    #[HIGHEST_BET_SLOT_INDEX, phase_n_sum, CURRENT_PHASE + CURRENT_TURN_INDEX + 4 -1]

    exec.account.get_item drop drop drop 
    #[highest_bet, phase_n_sum, CURRENT_PHASE + CURRENT_TURN_INDEX + 4 -1]

    add
    #[highest_bet + phase_n_sum, CURRENT_PHASE + CURRENT_TURN_INDEX + 4 -1]

    swap exec.account.set_item
    # []
end


export.find_next_active_player # why are you exporting this ?? we need to use this internally right 

    # update the slot for next active players public 
    # iterate over the number of players starting from the index of current player + 1 
    # for each player check is_fold = 0 or 1
    # if 0 then set this to slot NEXT_ACTIVE_PLAYER_KEY_INDEX
    # if 1 move to next player

    push.CURRENT_TURN_PLAYER_PUB_KEY_INDEX drop drop drop
    # => [CURRENT_TURN_PLAYER_PUB_KEY_INDEX]

    push.10 add # assuming there are 9 stats values for each player
    # => [CURRENT_TURN_PLAYER_PUB_KEY_INDEX + 10]

    push.NO_OF_PLAYERS_INDEX drop drop drop

    exec.account.get_item drop drop drop
    # x = no of players 
    # => [x, CURRENT_TURN_PLAYER_PUB_KEY_INDEX + 10]

    # why are we pushing 9 and then multiplying it with no of players ?
    push.9 mul 

    # => [9 * x, CURRENT_TURN_PLAYER_PUB_KEY_INDEX + 10] 9 * x would be fold index of last player why are we checking that ??
    push.NEXT_ACTIVE_PLAYER_KEY_INDEX drop drop drop 
    
    add

    lte
    #[1/0, CURRENT_TURN_PLAYER_PUB_KEY_INDEX + 10]

    drop dup
    #[CURRENT_TURN_PLAYER_PUB_KEY_INDEX + 10]


    while.true
        

        ## FIND THE NUMBER OF ROWS
        push.NO_OF_PLAYERS_INDEX drop drop drop
        exec.account.get_item drop drop drop 
        push.10 mul push.NEXT_ACTIVE_PLAYER_KEY_INDEX drop drop drop add
        lte
        #[1/0, CURRENT_TURN_PLAYER_PUB_KEY_INDEX + 10, CURRENT_TURN_PLAYER_PUB_KEY_INDEX + 10]

        mem_store.0
        if.mem_load.0
            #[CURRENT_TURN_PLAYER_PUB_KEY_INDEX + 10, CURRENT_TURN_PLAYER_PUB_KEY_INDEX + 10]
            
            push.1 sub
            #[CURRENT_TURN_PLAYER_PUB_KEY_INDEX + 10 - 1, CURRENT_TURN_PLAYER_PUB_KEY_INDEX + 10]

            exec.account.get_item drop drop drop # we should be in the is_fold of current player
            #[1/0, CURRENT_TURN_PLAYER_PUB_KEY_INDEX + 10]

            mem_store.1 # store is_fold inside the mem_store
            #[CURRENT_TURN_PLAYER_PUB_KEY_INDEX + 10]

            # now check if fold
            if.mem_load.1
                push.10 add
                #[CURRENT_TURN_PLAYER_PUB_KEY_INDEX + 10 + 10]

            else
                push.NEXT_ACTIVE_PLAYER_KEY_INDEX drop drop drop swap
                #[CURRENT_TURN_PLAYER_PUB_KEY_INDEX + 10, NEXT_ACTIVE_PLAYER_KEY_INDEX]

                push.10 sub
                #[CURRENT_TURN_PLAYER_PUB_KEY_INDEX, NEXT_ACTIVE_PLAYER_KEY_INDEX]

                exec.account.set_item
                push.0
            end

        else
            ## FIND THE NUMBER OF ROWS
            push.NO_OF_PLAYERS_INDEX drop drop drop
            exec.account.get_item drop drop drop 
            push.10 mul push.NEXT_ACTIVE_PLAYER_KEY_INDEX drop drop drop add
            # [num_of_rows, CURRENT_TURN_PLAYER_PUB_KEY_INDEX + 10]

            sub
            # [CURRENT_TURN_PLAYER_PUB_KEY_INDEX + 10 - num_of_rows]
    end
end

# some basic account methods 

export.basic_wallet::receive_asset
export.basic_wallet::send_asset
export.basic::auth_tx_rpo_falcon512

